style.
  .hidden {
    visibility:hidden;
  }

canvas#board(width="500px" height="500px")
.hidden
  img(
    id="pawn"
    src="https://github.com/ellos0/chess/blob/main/images/pawn.png?raw=true"    
  )
  img(
    id="apple"
    src="https://github.com/ellos0/chess/blob/main/images/apple.png?raw=true"
  )
  img(
    id="horse"
    src="https://github.com/ellos0/chess/blob/main/images/horse.png?raw=true"
  )
  img(
    id="man"
    src="https://github.com/ellos0/chess/blob/main/images/man.png?raw=true"
  )
  img(
    id="bpawn"
    src="https://github.com/ellos0/chess/blob/main/images/bpawn.png?raw=true"
  )
  img(
    id="bapple"
    src="https://github.com/ellos0/chess/blob/main/images/bapple.png?raw=true"
  )
  img(
    id="bhorse"
    src="https://github.com/ellos0/chess/blob/main/images/bhorse.png?raw=true"
  )
  img(
    id="bman"
    src="https://github.com/ellos0/chess/blob/main/images/bman.png?raw=true"
  )
  
script.
  const board = document.getElementById('board');
  const ctx = board.getContext('2d');


  const getPosFromScale = (x,y) => [x*parseFloat(board.getAttribute('width')),y*parseFloat(board.getAttribute('height'))];

  const getScaleFromPos = (x,y) => [x/parseFloat(board.getAttribute('width')),y/parseFloat(board.getAttribute('height'))];

  //tiles, mainly.

  const boardDimensions = getPosFromScale(1,1);
  const tileheight = boardDimensions[1]/8;
  const tilewidth = boardDimensions[0]/8;

  /*interface colorScheme {
    bright:string;
    dark:string
  };*/

  let maincolor = {
    bright:"#ede5b1",
    dark:"#50ce4c"
  };

  const drawScaledTile = (x,y,c) => {
    let px = getPosFromScale(x,y);
    ctx.fillStyle = c?maincolor.bright:maincolor.dark
    ctx.fillRect(px[0], px[1], tilewidth, tileheight);
  };

  const drawTiles = () => {
    for (let ypos = 0; ypos <= 1; ypos += (1/8)) {
      for (let xpos = 0; xpos <= 1; xpos += (1/8)) {
        drawScaledTile(xpos,ypos,((xpos+ypos)%(2/8)==0));
      };
    };
  };

  // pieces and stuff like that

  /*interface piece {
    x:number;
    y:number;
    type:number;
    player:boolean;
  };

  interface game {
    pieces:piece[];
    clientToMove:boolean;
    selectedPiece: piece | null;
  };*/

  const betterPush = (x,y) => {
    let list = x;
    list.push(y);
    return list;
  };

  const addPiece = (game,piece) => {
    if (!("id" in piece)) {
      piece.id = game.pieces.length;
    }
    game.pieces.push(piece);
    return game;
  }

  const renderPiece = (p) => {
    if (itemIsNull(p)) {
      return;
    }
    let px = getPosFromScale(p.x/8,p.y/8);
    let wimg;
    let bimg;
    switch (p.type) {
      case 0:
        //pawn
        wimg = document.getElementById("pawn");
        bimg = document.getElementById("bpawn");
        break;
      case 1:
        wimg = document.getElementById("horse");
        bimg = document.getElementById("bhorse");
        break;
      case 2:
        wimg = document.getElementById("apple");
        bimg = document.getElementById("bapple");
        break;
      case 3:
        wimg = document.getElementById("man");
        bimg = document.getElementById("bman");
        break;
    };
    ctx.drawImage(p.player?wimg:bimg,px[0],px[1],tilewidth,tileheight);
  };

  const getMousePos = (event) => {
    const rect = board.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    return [x,y];
  };

  const coolRound = (x) => {
    let t = Math.trunc(x);
    if (x-t>0.9) {
      return Math.ceil(x);
    } else if(x-t<0.1) {
      return Math.floor(x);
    } else {
      return t;
    };
  };

  const getMouseTile = (event) => {
    let pos = getMousePos(event);
    let scale = getScaleFromPos(pos[0],pos[1]);
    let x = scale[0]+(1/16);
    let y = scale[1]+(1/16);
    return [coolRound(x*7),coolRound(y*7)];
  };

  const getPieceFromPos = (game,pos) => {
    for (let i=0;i<game.pieces.length;i++) {
      let piece = game.pieces[i];
      if (!piece) {
        return;
      }
      if ((piece.x == pos[0]) && (piece.y == pos[1])) {
        return piece
      };
    };
  };

  const renderGame = (g) => {
    drawTiles();
    for (let i=0;i<g.pieces.length;i++) {
      let piece = g.pieces[i];
      renderPiece(piece);
    };
  };

  const arrayAdd = (x,y) => {
    let out = [];
    for (let i=0;i<x.length;i++) {
      out.push(x[i] + y[i]);
    };
    return out
  };

  const pieceToPosTuple = (piece) => piece?[piece.x,piece.y]:undefined;

  const containsList = (listOfLists, targetList) => listOfLists.some(list => JSON.stringify(list) === JSON.stringify(targetList));

  const itemIsNull = (x) => (x === null || x === undefined);

  const getPossibleMoveIdentities = (piece) => {
    if (itemIsNull(piece)) {
      console.warn("cannot get identities of null piece");
      return;
    };
    if (piece.type == 0) {
      return [
        [0,1],
        [0,-1],
        [1,0],
        [-1,0]
      ];
    } else if (piece.type == 1) {
      return [
        [0,1],
        [0,2],
        [1,0],
        [2,0],
        [0,-1],
        [0,-2],
        [-1,0],
        [-2,0]
      ]
    } else if (piece.type == 2) {
      return [
        [0,1],
        [0,2],
        [0,3],
        [0,4],
        [0,-1],
        [0,-2],
        [0,-3],
        [0,-4]
      ]
    } else if (piece.type == 3) {
      return [
        [
          [1,2],
          [-1,-2]
        ]
      ]
    }
  };

  const getMovePositions = (piece) => {
    if (itemIsNull(piece)) {
      console.warn("cannot get positions of null piece");
      return;
    };
    let identity = getPossibleMoveIdentities(piece);
    let out = [];
    for (let i=0;i<identity.length;i++) {
      let current = identity[i];
      let position = pieceToPosTuple(piece);
      out.push(arrayAdd(current, position));
    };
    return out;
  };

  const getIdFromPos = (game,pos) => getPieceFromPos.id;

  const removePiece = (game,piece) => {
    if (!piece) {
      return;
    }
    game.pieces.splice(piece.id,1);
  }

  const moveIsValid = (piece,pos) => {
    if (itemIsNull(piece)) {
      console.warn("cannot get validity of null piece");
      return;
    };
    let positions = getMovePositions(piece);
    return containsList(positions,pos);
  };


  const movePiece = (piece,pos) => {
    if (itemIsNull(piece)) {
      return;
    }
    piece.x = pos[0];
    piece.y = pos[1];
  };

  const getPiecesOfPlayer = (game,player) => {
    let count = 0;
    for (let i=0;i<game.pieces.length;i++) {
      count+=((game.pieces[i].player==player)?1:0);
    }
    return count;
  }

  const checkForLoss = (game,player) => {
    let p = getPiecesOfPlayer(game,player);
    return (p==0);
  }

  const checkForWinnerAndPrint = (game) => {
    if (checkForLoss(game,false)) {
      console.log("true has won");
    } 
    if (checkForLoss(game,true)) {
      console.log("false has won");
    }
  }

  const playerStep = (game,pos) => {
    let selected = getPieceFromPos(game,pos);
    if (game.selectedPiece == null) {
      if (selected != null) { 
        game.selectedPiece = selected;
        if (game.selectedPiece.player != game.player) {
          game.selectedPiece=null;
        }
      }
    } else {
      if (moveIsValid(game.selectedPiece,pos)) {
        if (!itemIsNull(selected)) {
          if (selected.player = !game.player) {
            removePiece(game,selected);
          } else {
            return;
          }
        }
        game.player = !game.player;
        movePiece(game.selectedPiece,pos);
        game.selectedPiece = null;
      }
    }
  }

  const setup = (g) => {
    if (itemIsNull(g)) {
      console.warn("setup failed");
      return;
    }
    g.pieces = [];
    addPiece(g,{
      x:3,
      y:2,
      type:0,
      player:false,
    })
    addPiece(g,{
      x:4,
      y:2,
      type:0,
      player:false
    })
    addPiece(g,{
      x:4,
      y:5,
      type:0,
      player:true
    })
    addPiece(g,{
      x:3,
      y:5,
      type:0,
      player:true
    })

    addPiece(g,{
      x:1,
      y:2,
      type:1,
      player:false
    })
    addPiece(g,{
      x:6,
      y:2,
      type:1,
      player:false
    })
    addPiece(g,{
      x:6,
      y:5,
      type:1,
      player:true
    })
    addPiece(g,{
      x:1,
      y:5,
      type:1,
      player:true
    })
    addPiece(g,{
      x:3,
      y:6,
      type:2,
      player:true
    })
    addPiece(g,{
      x:4,
      y:6,
      type:2,
      player:true
    })
    addPiece(g,{
      x:3,
      y:1,
      type:2,
      player:false
    })
    addPiece(g,{
      x:4,
      y:1,
      type:2,
      player:false
    })
  }

  const main = () => {

    let newGame = {
      pieces:[],
      player:false
    };
    setup(newGame)

    renderGame(newGame);

    board.addEventListener("click", (event) => {
      let pos = getMouseTile(event);
      playerStep(newGame,pos);
      checkForWinnerAndPrint(newGame);
      renderGame(newGame);
    });
  };
  main();
